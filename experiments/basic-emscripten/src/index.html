<script type="module">
    import Module from './module.js';

    const module = await Module();
    console.log(module);

    // By convention all C-functions, wether they are exported from 'us' (like 'saySomething')
    // or emscripten (like 'malloc') are prepended with and underscore '_':
    const a = module._saySomething();
    const b = module.ccall('saySomething', 'number', [], []); // does essentially the same as the preceding line
    console.log('a, b = ', a, b);

    // If a function has only ints/floats (number) as inputs and outputs currently (august 2021) ccall and hence cwrap
    // does not alter the behaviour of the original function.
    const intSqrt = module.cwrap('intSqrt', 'number', ['number']);
    console.log('integer square root of 10 = ', intSqrt(10));
    console.log('integer square root of 17 = ', module._intSqrt(17));

    // ccall supports 'array' as input (but not as output), however only in the form of Int8Array which is the reason
    // why we work with the emscripten HEAP to pass data between javascript and wasm.
    const myVector = new Float64Array([1.0, 1.0]);
    // Allocate memory on the emscripten HEAP:
    const ptrMyVector = module._malloc(8*myVector.length);
    // The start address - as *byte* offset - of the allocated region within WASM Memory.
    console.log('ptrMyVector = ', ptrMyVector);
    console.log('myVector = ', myVector);
    // *Copy* myVector into emscripten HEAP. Note float64 needs *8* bytes:
    module.HEAPF64.set(myVector, ptrMyVector/8);
    // The first argument to 'norm' is a pointer which is represented as a 'number' by ccall nomenclature.
    const myNorm = module.ccall('norm', 'number', ['number', 'number'], [ptrMyVector, myVector.length]);
    // The wrapper 'ccall' is not really needed here since the following also works:
    const _myNorm = module._norm(ptrMyVector, myVector.length);
    console.log('myNorm  = ', myNorm);
    console.log('_myNorm = ', _myNorm);
    // Free the memory associated with ptrMyVector since it is not needed anymore:
    module._free(ptrMyVector);

    // An example for a function returning an array.
    const length = 5;
    // We use Int32 here which needs 4 bytes of memory:
    const ptrMyIntegers = module._malloc(4*length);
    console.log('ptrMyIntegers = ', ptrMyIntegers);
    // Here we initialize the input array directly within the emscripten HEAP (next two lines):
    const myIntegers = module.HEAP32.subarray(ptrMyIntegers/4, ptrMyIntegers/4 + length);
    for (let i = 0; i < length; ++i) { myIntegers[i] = i; }
    console.log('myIntegers = ', myIntegers);
    const ptrSquares = module._squareAll(ptrMyIntegers, myIntegers.length);
    const mySquares = module.HEAP32.subarray(ptrSquares/4, ptrSquares/4 + myIntegers.length);
    console.log('mySquares = ', mySquares);
    console.log('mySquares at index three = ', module.getValue(ptrSquares + 4*3, 'i32'));
    // Free all everything allocated on the heap which is not needed anymore:
    module._free(ptrMyIntegers);
    module._free(ptrSquares); // was allocated within C-code! See implementation of squareAll(...).

    // Uncomment the following code to observe the effect of not freeing memory (e.g. by inspecting htop).
    // You might need to set something like -s INITIAL_MEMORY=268435456 (~256MB) for having more memory available.
    /*
    const len = 100*256*1024;
    const ptrIn = module._malloc(4*len);
    const input = module.HEAP32.subarray(ptrIn/4, ptrIn/4 + len);
    const squareAll = module._squareAll;
    for (let i = 0; i < len; ++i) { input[i] = i; }
    for (let i = 0; i < 10; ++i) {
        // Each loop allocates 100MiB of memory on the emscripten HEAP.
        const ptrOut = squareAll(ptrIn, len);
        //const output = module.HEAP32.subarray(ptrOut/4, ptrOut/4 + len);
        //console.log('ptrOut = ', ptrOut);
        //console.log(output);
        // Now we do not free anything !!!
        //module._free(ptrOut);
    }
    */
</script>
<body>
    <h1>Experiment - Basic Emscripten Usage</h1>

    Open the console!
</body>
